if(length(queue)) {
for(j in length(queue):1) {
inc(queue[[j]]$serviceTimeWaited)
}
# The (possibley new) person at the front of the queue has had to wait
# there one more interval.
inc(queue[[1]]$serviceTimeWaitedAtHeadOfQueue)
}
# End of the interval, what is the state of things
queueLengths[i] = length(queue)
numbCustomers[i] = totalCustomers
}
ptm2 = proc.time()
t_sim = ptm2[3] - ptm1[3]
cat("The simulation takes", t_sim, "s" )
plot(queueLengths[1:7200], type="o", col="blue", pch=20, main="Queue lengths over time",
xlab="Interval", ylab="Queue length")
plot(numbCustomers[1:7200], type="o", col="blue", pch=20, main="# of Customers over time",
xlab="Interval", ylab="# of customers in system")
totalAbandons
totalAbandons/length(arrivalEpochs)
dat3 <- data_valid[data_valid$day_of_month==3,]
### get the arrival time and service time for Oct ###
data <- read.table(file = "C:/Users/Keguo/Dropbox/GitHub/queue-systems/CallCenter/october.txt", header = T)
head(data)
## we only need "PS" type service and q_start greater than 0 with service time greater than 0 ##
## "PS" type
q_start <- strptime(paste(data$date, data$q_start), format='%y%m%d %H:%M:%S')
data$q_start_date <- q_start
data$day_of_month <- as.numeric(format(q_start, '%d'))
data$day_of_week <- (data$day_of_month + 4) %% 7
data$q_start_hour_of_day <- as.numeric(format(q_start, '%H'))
data$q_start_min_of_hour <- as.numeric(format(q_start, '%M'))
data$q_start_sec_of_min <- as.numeric(format(q_start, '%S'))
data$q_start_sec_of_day <- (data$q_start_hour_of_day*3600
+ data$q_start_min_of_hour*60
+ data$q_start_sec_of_min)
ser_start <- strptime(paste(data$date, data$ser_start), format='%y%m%d %H:%M:%S')
data$ser_start_date <- ser_start
data$ser_start_day_of_month <- as.numeric(format(ser_start, '%d'))
data$ser_start_hour_of_day <- as.numeric(format(ser_start, '%H'))
data$ser_start_min_of_hour <- as.numeric(format(ser_start, '%M'))
data$ser_start_sec_of_min <- as.numeric(format(ser_start, '%S'))
data$ser_start_sec_of_day <- (data$ser_start_hour_of_day*3600
+ data$ser_start_min_of_hour*60
+ data$ser_start_sec_of_min)
data_PS <- split(data, data$type )$PS
# valid data (positive service time or queue time)
data_valid <- data_PS[data_PS$ser_time > 0 | data_PS$q_time > 0,]
head(data_valid[,c('q_start_sec_of_day','ser_start_sec_of_day')],50)
data_valid$arrival_sec_of_day = -1
for(i in 1:nrow(data_valid)){
if(data_valid$q_time[i] > 0){
data_valid$arrival_sec_of_day[i] <- data_valid$q_start_sec_of_day[i] - 3600*7
} else{data_valid$arrival_sec_of_day[i] <- data_valid$ser_start_sec_of_day[i] - 3600*7}
}
# arrival time for one day
dat1 <- data_valid[data_valid$day_of_month==1,]
arrivalEpoch <- sort(dat1$arrival_sec_of_day)
dat2 <- data_valid[data_valid$day_of_month==2,]
arrivalEpoch <- sort(dat2$arrival_sec_of_day)
dat3 <- data_valid[data_valid$day_of_month==3,]
arrivalEpoch <- sort(dat3$arrival_sec_of_day)
dat3 <- data_valid[data_valid$day_of_month==3,]
arrivalEpoch3 <- sort(dat3$arrival_sec_of_day)
library(proto)
set.seed(1)
# arrivalEpochs <- read.table(file = "C:/Users/Keguo/Dropbox/GitHub/queue-systems/CallCenter/arrivalEpochs_tmax10000_prec1000_g1.txt",)$V1
arrivalEpochs <- arrivalEpochs3[-1]
timeline <- seq(1, max(arrivalEpochs), 1)
serviceTimeSeq <- sample(serviceTime, length(arrivalEpochs), replace = T)
patientTimeSeq <- sample(patientTime, length(arrivalEpochs), replace = T)
#### Functions ####
# R is missing a nice way to do ++, so we use this
inc <- function(x) {
eval.parent(substitute(x <- x + 1))
}
dec <- function(x) {
eval.parent(substitute(x <- x - 1))
}
# Main object, really a "proto" function
person <- proto(
epochArrived = 0,
# How much teller time will this person demand?
serviceTimeNeeded = 0,
serviceTimeWaited = 0,
serviceTimeWaitedAtHeadOfQueue = 0,
patientTime = 0
)
numbServers_high = 7
numbServers_low = 5
totalCustomers = 0
totalAbandons = 0
serviceCompletionEpoch = rep(0, numbServers_high)
k = 1 # counting arrival orders
abandonEpoch = c()
queue = list()
frontOfLineWaits = c()
queueLengths = rep(20.5, length(timeline))
numbCustomers = rep(20.5, length(timeline))
waitEpoch = c()
ptm1 = proc.time()
#### Main loop ####
for(i in timeline) {
# Check if anyone is leaving the servers
for(j in 1:numbServers_high) {
if(serviceCompletionEpoch[j] == i) {
dec(totalCustomers)
# They are leaving the queue, slot to 0
serviceCompletionEpoch[j] = 0
}
}
# See if a new person is to be added to the queue
while(i == arrivalEpochs[k] & k <= length(arrivalEpochs)) {
inc(totalCustomers)
newPerson = person$proto(epochArrived = i,
serviceTimeNeeded = serviceTimeSeq[k],
patientTime = patientTimeSeq[k])
queue = c(queue, newPerson)
inc(k)
}
# If anyone is dropping the waiting line?
if(length(queue)) {
for(j in length(queue):1) {
if(queue[[j]]$serviceTimeWaited >= queue[[j]]$patientTime){
queue[[j]] = NULL
inc(totalAbandons)
abandonEpoch = c(abandonEpoch, i)
dec(totalCustomers)
}
}
}
# Can we place someone into a slot?
for(j in 1:numbServers_high) {
# If this slot is free
if(serviceCompletionEpoch[j]==0) {
if(length(queue) > 0) {
if(j<=numbServers_low | i<3600*8){
placedPerson = queue[[1]]
serviceCompletionEpoch[j] = i + placedPerson$serviceTimeNeeded
waitEpoch = c(waitEpoch, placedPerson$serviceTimeWaited)
# Only interested in these if person waited 1 or more intevals at front
# of line
if(placedPerson$serviceTimeWaitedAtHeadOfQueue) {
frontOfLineWaits = c(frontOfLineWaits,
placedPerson$serviceTimeWaitedAtHeadOfQueue)
}
queue[[1]] = NULL
}
}
}
}
# Everyone left in the queue has now waited one more interval to be served
if(length(queue)) {
for(j in length(queue):1) {
inc(queue[[j]]$serviceTimeWaited)
}
# The (possibley new) person at the front of the queue has had to wait
# there one more interval.
inc(queue[[1]]$serviceTimeWaitedAtHeadOfQueue)
}
# End of the interval, what is the state of things
queueLengths[i] = length(queue)
numbCustomers[i] = totalCustomers
}
ptm2 = proc.time()
t_sim = ptm2[3] - ptm1[3]
cat("The simulation takes", t_sim, "s" )
plot(queueLengths[1:7200], type="o", col="blue", pch=20, main="Queue lengths over time",
xlab="Interval", ylab="Queue length")
plot(numbCustomers[1:7200], type="o", col="blue", pch=20, main="# of Customers over time",
xlab="Interval", ylab="# of customers in system")
totalAbandons
totalAbandons/length(arrivalEpochs)
arrivalEpoch3
arrivalEpochs3 <- sort(dat3$arrival_sec_of_day)
library(proto)
set.seed(1)
# arrivalEpochs <- read.table(file = "C:/Users/Keguo/Dropbox/GitHub/queue-systems/CallCenter/arrivalEpochs_tmax10000_prec1000_g1.txt",)$V1
arrivalEpochs <- arrivalEpochs3[-1]
timeline <- seq(1, max(arrivalEpochs), 1)
serviceTimeSeq <- sample(serviceTime, length(arrivalEpochs), replace = T)
patientTimeSeq <- sample(patientTime, length(arrivalEpochs), replace = T)
#### Functions ####
# R is missing a nice way to do ++, so we use this
inc <- function(x) {
eval.parent(substitute(x <- x + 1))
}
dec <- function(x) {
eval.parent(substitute(x <- x - 1))
}
# Main object, really a "proto" function
person <- proto(
epochArrived = 0,
# How much teller time will this person demand?
serviceTimeNeeded = 0,
serviceTimeWaited = 0,
serviceTimeWaitedAtHeadOfQueue = 0,
patientTime = 0
)
numbServers_high = 7
numbServers_low = 5
totalCustomers = 0
totalAbandons = 0
serviceCompletionEpoch = rep(0, numbServers_high)
k = 1 # counting arrival orders
abandonEpoch = c()
queue = list()
frontOfLineWaits = c()
queueLengths = rep(20.5, length(timeline))
numbCustomers = rep(20.5, length(timeline))
waitEpoch = c()
ptm1 = proc.time()
#### Main loop ####
for(i in timeline) {
# Check if anyone is leaving the servers
for(j in 1:numbServers_high) {
if(serviceCompletionEpoch[j] == i) {
dec(totalCustomers)
# They are leaving the queue, slot to 0
serviceCompletionEpoch[j] = 0
}
}
# See if a new person is to be added to the queue
while(i == arrivalEpochs[k] & k <= length(arrivalEpochs)) {
inc(totalCustomers)
newPerson = person$proto(epochArrived = i,
serviceTimeNeeded = serviceTimeSeq[k],
patientTime = patientTimeSeq[k])
queue = c(queue, newPerson)
inc(k)
}
# If anyone is dropping the waiting line?
if(length(queue)) {
for(j in length(queue):1) {
if(queue[[j]]$serviceTimeWaited >= queue[[j]]$patientTime){
queue[[j]] = NULL
inc(totalAbandons)
abandonEpoch = c(abandonEpoch, i)
dec(totalCustomers)
}
}
}
# Can we place someone into a slot?
for(j in 1:numbServers_high) {
# If this slot is free
if(serviceCompletionEpoch[j]==0) {
if(length(queue) > 0) {
if(j<=numbServers_low | i<3600*8){
placedPerson = queue[[1]]
serviceCompletionEpoch[j] = i + placedPerson$serviceTimeNeeded
waitEpoch = c(waitEpoch, placedPerson$serviceTimeWaited)
# Only interested in these if person waited 1 or more intevals at front
# of line
if(placedPerson$serviceTimeWaitedAtHeadOfQueue) {
frontOfLineWaits = c(frontOfLineWaits,
placedPerson$serviceTimeWaitedAtHeadOfQueue)
}
queue[[1]] = NULL
}
}
}
}
# Everyone left in the queue has now waited one more interval to be served
if(length(queue)) {
for(j in length(queue):1) {
inc(queue[[j]]$serviceTimeWaited)
}
# The (possibley new) person at the front of the queue has had to wait
# there one more interval.
inc(queue[[1]]$serviceTimeWaitedAtHeadOfQueue)
}
# End of the interval, what is the state of things
queueLengths[i] = length(queue)
numbCustomers[i] = totalCustomers
}
ptm2 = proc.time()
t_sim = ptm2[3] - ptm1[3]
cat("The simulation takes", t_sim, "s" )
plot(queueLengths[1:7200], type="o", col="blue", pch=20, main="Queue lengths over time",
xlab="Interval", ylab="Queue length")
plot(numbCustomers[1:7200], type="o", col="blue", pch=20, main="# of Customers over time",
xlab="Interval", ylab="# of customers in system")
totalAbandons
totalAbandons/length(arrivalEpochs)
serviceTime <- data_valid$ser_time[data_valid$ser_time > 0]
hist(serviceTime, breaks = 1000, xlim = c(0,1000))
#patient time
patientTime <- data_PS$q_time[data_PS$outcome=='HANG' & data_PS$q_time>0]
length(patientTime)
hist(patientTime, breaks=60)
#arrival Epochs
a = cut(arrivalEpochs, breaks = 3600*(0:17))
plot(7:23,table(a), type = 'o')
library(proto)
set.seed(1)
# arrivalEpochs <- read.table(file = "C:/Users/Keguo/Dropbox/GitHub/queue-systems/CallCenter/arrivalEpochs_tmax10000_prec1000_g1.txt",)$V1
arrivalEpochs <- arrivalEpochs3[-1]
timeline <- seq(1, max(arrivalEpochs), 1)
serviceTimeSeq <- sample(serviceTime, length(arrivalEpochs), replace = T)
patientTimeSeq <- sample(patientTime, length(arrivalEpochs), replace = T)
#### Functions ####
# R is missing a nice way to do ++, so we use this
inc <- function(x) {
eval.parent(substitute(x <- x + 1))
}
dec <- function(x) {
eval.parent(substitute(x <- x - 1))
}
# Main object, really a "proto" function
person <- proto(
epochArrived = 0,
# How much teller time will this person demand?
serviceTimeNeeded = 0,
serviceTimeWaited = 0,
serviceTimeWaitedAtHeadOfQueue = 0,
patientTime = 0
)
numbServers_high = 7
numbServers_low = 5
totalCustomers = 0
totalAbandons = 0
serviceCompletionEpoch = rep(0, numbServers_high)
k = 1 # counting arrival orders
abandonEpoch = c()
queue = list()
frontOfLineWaits = c()
queueLengths = rep(20.5, length(timeline))
numbCustomers = rep(20.5, length(timeline))
waitEpoch = c()
ptm1 = proc.time()
#### Main loop ####
for(i in timeline) {
# Check if anyone is leaving the servers
for(j in 1:numbServers_high) {
if(serviceCompletionEpoch[j] == i) {
dec(totalCustomers)
# They are leaving the queue, slot to 0
serviceCompletionEpoch[j] = 0
}
}
# See if a new person is to be added to the queue
while(i == arrivalEpochs[k] & k <= length(arrivalEpochs)) {
inc(totalCustomers)
newPerson = person$proto(epochArrived = i,
serviceTimeNeeded = serviceTimeSeq[k],
patientTime = patientTimeSeq[k])
queue = c(queue, newPerson)
inc(k)
}
# If anyone is dropping the waiting line?
if(length(queue)) {
for(j in length(queue):1) {
if(queue[[j]]$serviceTimeWaited >= queue[[j]]$patientTime){
queue[[j]] = NULL
inc(totalAbandons)
abandonEpoch = c(abandonEpoch, i)
dec(totalCustomers)
}
}
}
# Can we place someone into a slot?
for(j in 1:numbServers_high) {
# If this slot is free
if(serviceCompletionEpoch[j]==0) {
if(length(queue) > 0) {
if(j<=numbServers_low | i<3600*8){
placedPerson = queue[[1]]
serviceCompletionEpoch[j] = i + placedPerson$serviceTimeNeeded
waitEpoch = c(waitEpoch, placedPerson$serviceTimeWaited)
# Only interested in these if person waited 1 or more intevals at front
# of line
if(placedPerson$serviceTimeWaitedAtHeadOfQueue) {
frontOfLineWaits = c(frontOfLineWaits,
placedPerson$serviceTimeWaitedAtHeadOfQueue)
}
queue[[1]] = NULL
}
}
}
}
# Everyone left in the queue has now waited one more interval to be served
if(length(queue)) {
for(j in length(queue):1) {
inc(queue[[j]]$serviceTimeWaited)
}
# The (possibley new) person at the front of the queue has had to wait
# there one more interval.
inc(queue[[1]]$serviceTimeWaitedAtHeadOfQueue)
}
# End of the interval, what is the state of things
queueLengths[i] = length(queue)
numbCustomers[i] = totalCustomers
}
ptm2 = proc.time()
t_sim = ptm2[3] - ptm1[3]
cat("The simulation takes", t_sim, "s" )
plot(queueLengths[1:7200], type="o", col="blue", pch=20, main="Queue lengths over time",
xlab="Interval", ylab="Queue length")
plot(numbCustomers[1:7200], type="o", col="blue", pch=20, main="# of Customers over time",
xlab="Interval", ylab="# of customers in system")
totalAbandons
totalAbandons/length(arrivalEpochs)
library(proto)
set.seed(1)
# arrivalEpochs <- read.table(file = "C:/Users/Keguo/Dropbox/GitHub/queue-systems/CallCenter/arrivalEpochs_tmax10000_prec1000_g1.txt",)$V1
arrivalEpochs <- arrivalEpochs3[-1]
timeline <- seq(1, max(arrivalEpochs), 1)
serviceTimeSeq <- sample(serviceTime, length(arrivalEpochs), replace = T)
patientTimeSeq <- sample(patientTime, length(arrivalEpochs), replace = T)
#### Functions ####
# R is missing a nice way to do ++, so we use this
inc <- function(x) {
eval.parent(substitute(x <- x + 1))
}
dec <- function(x) {
eval.parent(substitute(x <- x - 1))
}
# Main object, really a "proto" function
person <- proto(
epochArrived = 0,
# How much teller time will this person demand?
serviceTimeNeeded = 0,
serviceTimeWaited = 0,
serviceTimeWaitedAtHeadOfQueue = 0,
patientTime = 0
)
numbServers = 6
totalCustomers = 0
totalAbandons = 0
serviceCompletionEpoch = rep(0, numbServers)
k = 1 # counting arrival orders
abandonEpoch = c()
queue = list()
frontOfLineWaits = c()
queueLengths = rep(20.5, length(timeline))
numbCustomers = rep(20.5, length(timeline))
waitEpoch = c()
ptm1 = proc.time()
#### Main loop ####
for(i in timeline) {
# Check if anyone is leaving the servers
for(j in 1:numbServers) {
if(serviceCompletionEpoch[j] == i) {
dec(totalCustomers)
# They are leaving the queue, slot to 0
serviceCompletionEpoch[j] = 0
}
}
# See if a new person is to be added to the queue
while(i == arrivalEpochs[k] & k <= length(arrivalEpochs)) {
inc(totalCustomers)
newPerson = person$proto(epochArrived = i,
serviceTimeNeeded = serviceTimeSeq[k],
patientTime = patientTimeSeq[k])
queue = c(queue, newPerson)
inc(k)
}
# If anyone is dropping the waiting line?
if(length(queue)) {
for(j in length(queue):1) {
if(queue[[j]]$serviceTimeWaited >= queue[[j]]$patientTime){
queue[[j]] = NULL
inc(totalAbandons)
abandonEpoch = c(abandonEpoch, i)
dec(totalCustomers)
}
}
}
# Can we place someone into a slot?
for(j in 1:numbServers) {
# If this slot is free
if(serviceCompletionEpoch[j]==0) {
if(length(queue) > 0) {
placedPerson = queue[[1]]
serviceCompletionEpoch[j] = i + placedPerson$serviceTimeNeeded
waitEpoch = c(waitEpoch, placedPerson$serviceTimeWaited)
# Only interested in these if person waited 1 or more intevals at front
# of line
if(placedPerson$serviceTimeWaitedAtHeadOfQueue) {
frontOfLineWaits = c(frontOfLineWaits,
placedPerson$serviceTimeWaitedAtHeadOfQueue)
}
queue[[1]] = NULL
}
}
}
# Everyone left in the queue has now waited one more interval to be served
if(length(queue)) {
for(j in length(queue):1) {
inc(queue[[j]]$serviceTimeWaited)
}
# The (possibley new) person at the front of the queue has had to wait
# there one more interval.
inc(queue[[1]]$serviceTimeWaitedAtHeadOfQueue)
}
# End of the interval, what is the state of things
queueLengths[i] = length(queue)
numbCustomers[i] = totalCustomers
}
ptm2 = proc.time()
t_sim = ptm2[3] - ptm1[3]
cat("The simulation takes", t_sim, "s" )
plot(queueLengths[1:7200], type="o", col="blue", pch=20, main="Queue lengths over time",
xlab="Interval", ylab="Queue length")
plot(numbCustomers[1:7200], type="o", col="blue", pch=20, main="# of Customers over time",
xlab="Interval", ylab="# of customers in system")
totalAbandons
totalAbandons/length(arrivalEpochs)
head(arrivalEpoch3)
a = cut(arrivalEpochs, breaks = 3600*(0:17))
plot(7:23,table(a), type = 'o')
