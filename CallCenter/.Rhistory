}
# Can we place someone into a slot?
for(j in 1:numbServers) {
# If this slot is free
if(!serviceCompletionEpoch[j]) {
if(length(queue) > 0) {
placedPerson = queue[[1]]
serviceCompletionEpoch[j] = i + placedPerson$serviceEpochsNeeded
waitEpoch = c(waitEpoch, placedPerson$serviceEpochsWaited)
# Only interested in these if person waited 1 or more intevals at front
# of line
if(placedPerson$serviceEpochsWaitedAtHeadOfQueue) {
frontOfLineWaits = c(frontOfLineWaits,
placedPerson$serviceEpochsWaitedAtHeadOfQueue)
}
# Remove placed person from queue
queue[[1]] = NULL
}
}
}
# Everyone left in the queue has now waited one more interval to be served
if(length(queue)) {
for(j in 1:length(queue)) {
inc(queue[[j]]$serviceEpochsWaited)
}
# The (possibley new) person at the front of the queue has had to wait
# there one more interval.
inc(queue[[1]]$serviceEpochsWaitedAtHeadOfQueue)
}
# End of the interval, what is the state of things
queueLengths[i] = length(queue)
numbCustomers[i] = totalCustomers
inc(Tkt[totalCustomers+1])
}
#### Output ####
plot(queueLengths, type="o", col="blue", pch=20, main="Queue lengths over time",
xlab="Interval", ylab="Queue length")
plot(numbCustomers, type="o", col="blue", pch=20, main="# of Customers over time",
xlab="Interval", ylab="Queue length")
# plot(totalCustomers, type="o", col="blue", pch=20,
#      main="Total Customers over time", xlab="Person", ylab="Wait time")
proc.time() - ptm
max(which(Dkt != 0)) == max(which(Akt != 0))
max(which(Dkt != 0)) == max(which(Tkt != 0)) - 1
m = max(which(Dkt != 0))
lamb = Akt[1:m]/Tkt[1:m]    # lamb_0, lamb_1 ,..., mu_(m-1)
mu = Dkt[1:m]/Tkt[2:(m+1)]  # mu_1, mu_2 ,..., mu_m
lamb
mu
plot(9:59, lamb[10:60])
plot(10:60, mu[10:60])
# lamb[is.nan(lamb)] = 0
# lamb[lamb == 0] = 0.001
# lamb[is.infinite(lamb)] = max(lamb)
# mu[is.nan(mu)] = 0
mu[mu == 0] = 0.001
# lamb[is.infinite(mu)] = max(mu)
rkt = rep(1,m+1) # r0, r1, ... ,
for(i in 2:m+1){
rkt[i] = prod(lamb[1:(i-1)])/prod(mu[1:(i-1)])
}
rkt
alphakt = rep(0,m+1)
for (i in 1:(m+1)){
alphakt[i] = rkt[i]/sum(rkt)
}
alphakt
plot(x=1:(m+1), y=alphakt)
Dkt2 = Dkt
Dkt2[Dkt == 0] = 0.1
mu2 = Dkt2[1:m]/Tkt[2:(m+1)]  #mu_1, mu_2 ,..., mu_m
mu2
rkt2 = rep(1,m+1) # r0, r1, ... ,
for(i in 2:m+1){
rkt2[i] = prod(lamb[1:(i-1)])/prod(mu2[1:(i-1)])
}
rkt2
alphakt2 = rep(0,m+1)
for (i in 1:(m+1)){
alphakt2[i] = rkt2[i]/sum(rkt2)
}
alphakt2
plot(x=1:(m+1), y=alphakt2)
Z = rexp(30, 1)
t = seq(0, sum(Z), length.out = 200)
X = t * 0
for (i in 1:30) {
Zc = cumsum(Z)
X[t >= Zc[i]] = i
}
par(cex.main = 1.5, cex.axis = 1.2, cex.lab = 1.5)
plot(c(0, sum(Z)), c(0, 30), type = "n", xlab = "$t$",
ylab = "")
curve(x * 1, add = TRUE, col = rgb(1, 0, 0), lwd = 2,
lty = 2, xlab = "$t$", ylab = "$X_t$")
lines(t, X, lwd = 3, type = "s")
title("A Poisson process sample path")
Z = rexp(30, 1)
t = seq(0, sum(Z), length.out = 200)
X = t * 0
for (i in 1:30) {
Zc = cumsum(Z)
X[t >= Zc[i]] = i
}
par(cex.main = 1.5, cex.axis = 1.2, cex.lab = 1.5)
plot(c(0, sum(Z)), c(0, 30), type = "n", xlab = "$t$",
ylab = "")
curve(x * 1, add = TRUE, col = rgb(1, 0, 0), lwd = 2,
lty = 2, xlab = "time", ylab = "arrivals")
lines(t, X, lwd = 3, type = "s")
title("A Poisson process sample path")
Z = rexp(30, 1)
t = seq(0, sum(Z), length.out = 200)
X = t * 0
for (i in 1:30) {
Zc = cumsum(Z)
X[t >= Zc[i]] = i
}
par(cex.main = 1.5, cex.axis = 1.2, cex.lab = 1.5)
plot(c(0, sum(Z)), c(0, 30), type = "n", xlab = "$t$",
ylab = "")
curve(x * 1, add = TRUE, col = rgb(1, 0, 0), lwd = 2,
lty = 2, xlab = "time", ylab = "arrivals")
lines(t, X, lwd = 3, type = "s")
title("A Poisson process sample path")
Z = rexp(30, 1)
t = seq(0, sum(Z), length.out = 200)
X = t * 0
for (i in 1:30) {
Zc = cumsum(Z)
X[t >= Zc[i]] = i
}
par(cex.main = 1.5, cex.axis = 1.2, cex.lab = 1.5)
plot(c(0, sum(Z)), c(0, 30), type = "n", xlab = "$t$",
ylab = "")
curve(x * 1, add = TRUE, col = rgb(1, 0, 0), lwd = 2,
lty = 2, xlab = "time", ylab = "arrivals")
lines(t, X, lwd = 3, type = "s")
title("A Poisson process sample path")
Z = rexp(30, 1)
t = seq(0, sum(Z), length.out = 200)
X = t * 0
for (i in 1:30) {
Zc = cumsum(Z)
X[t >= Zc[i]] = i
}
par(cex.main = 1.5, cex.axis = 1.2, cex.lab = 1.5)
plot(c(0, sum(Z)), c(0, 30), type = "n", xlab = "$t$",
ylab = "")
curve(x * 1, add = TRUE, col = rgb(1, 0, 0), lwd = 2,
lty = 2, xlab = "time", ylab = "arrivals")
lines(t, X, lwd = 3, type = "s")
title("A Poisson process sample path")
#### http://www.statisticsblog.com/2011/10/waiting-in-line-waiting-on-r/ ####
tmax <- 1
t <- 0
numbServers = 4
# Total time to track
precision = 100  #precision
epochSeq = seq(1, tmax*precision, 1)
meanServiceTime = .1
ptm = proc.time()
#### NHPP Arrivals ####
get_nhpp_realization <- function(lambda){
set.seed(10000)
lambda_star <- function(){
max(sapply(seq(1, tmax,length.out=1000), lambda))*2}
Lambda <- function(tupper){
integrate(f = lambda, lower = 0, upper = tupper)$value}
X <- numeric()
while(t <= tmax){
u <- runif(1)
t <- t - log(u)/lambda_star()
if(runif(1) < lambda(t)/lambda_star()) {
X <- c(X,t)
}
}
return(floor(X*precision))
}
l = 35
b = 10/35
g = 1
lambda <- function(t)  l*(1+b*sin(g*t))
arrivalEpochs <- get_nhpp_realization(lambda)
proc.time() - ptm
# Average time each person takes at the teller, discretized exponential
# distribution assumed Times will be augmented by one, so that everyone takes at
# least 1 interval to serve
# write.table(arrivalEpochs, file = "arrivalEpochs_tmax10000_prec1000.txt",
# row.names = F, col.names = F)
#### Libraries ####
# Use the proto library to treat people like objects in traditional oop
library("proto")
#### Functions ####
# R is missing a nice way to do ++, so we use this
inc <- function(x) {
eval.parent(substitute(x <- x + 1))
}
dec <- function(x) {
eval.parent(substitute(x <- x - 1))
}
ptm = proc.time()
set.seed(1)
# Main object, really a "proto" function
person <- proto(
intervalArrived = 0,
# How much teller time will this person demand?
serviceEpochsNeeded = (floor(rexp(1, 1/meanServiceTime)*precision) + 1),
serviceEpochsWaited = 0,
serviceEpochsWaitedAtHeadOfQueue = 0
)
#### INITIALIZATION ####
queueLengths = rep(20.5, length(epochSeq))
totalCustomers = 0
numbCustomers = rep(20.5, length(epochSeq))
serviceCompletionEpoch = rep(0, numbServers)
waitEpoch = c()
leavingTimes = c()
queue = list()
frontOfLineWaits = c()
Akt = rep(0, length(arrivalEpochs))  #Akt, k=0,1,2,
Dkt = rep(0, length(arrivalEpochs))  #Dkt, k=1,2,
Tkt = rep(0, length(arrivalEpochs))  #Tkt, k=0,1,2
k = 1 # counting arrival orders
#### Main loop ####
for(i in epochSeq) {
# Check if anyone is leaving the servers
for(j in 1:numbServers) {
if(serviceCompletionEpoch[j] == i) {
inc(Dkt[totalCustomers])
dec(totalCustomers)
# They are leaving the queue, slot to 0
serviceCompletionEpoch[j] = 0
leavingTimes = c(leavingTimes, i)
}
}
# See if a new person is to be added to the queue
while(i == arrivalEpochs[k] & k <= length(arrivalEpochs)) {
inc(Akt[totalCustomers+1])
inc(totalCustomers)
newPerson = as.proto(person$as.list())
newPerson$intervalArrived = i
queue = c(queue, newPerson)
inc(k)
}
# Can we place someone into a slot?
for(j in 1:numbServers) {
# If this slot is free
if(!serviceCompletionEpoch[j]) {
if(length(queue) > 0) {
placedPerson = queue[[1]]
serviceCompletionEpoch[j] = i + placedPerson$serviceEpochsNeeded
waitEpoch = c(waitEpoch, placedPerson$serviceEpochsWaited)
# Only interested in these if person waited 1 or more intevals at front
# of line
if(placedPerson$serviceEpochsWaitedAtHeadOfQueue) {
frontOfLineWaits = c(frontOfLineWaits,
placedPerson$serviceEpochsWaitedAtHeadOfQueue)
}
# Remove placed person from queue
queue[[1]] = NULL
}
}
}
# Everyone left in the queue has now waited one more interval to be served
if(length(queue)) {
for(j in 1:length(queue)) {
inc(queue[[j]]$serviceEpochsWaited)
}
# The (possibley new) person at the front of the queue has had to wait
# there one more interval.
inc(queue[[1]]$serviceEpochsWaitedAtHeadOfQueue)
}
# End of the interval, what is the state of things
queueLengths[i] = length(queue)
numbCustomers[i] = totalCustomers
inc(Tkt[totalCustomers+1])
}
#### Output ####
plot(queueLengths, type="o", col="blue", pch=20, main="Queue lengths over time",
xlab="Interval", ylab="Queue length")
plot(numbCustomers, type="o", col="blue", pch=20, main="# of Customers over time",
xlab="Interval", ylab="Queue length")
# plot(totalCustomers, type="o", col="blue", pch=20,
#      main="Total Customers over time", xlab="Person", ylab="Wait time")
proc.time() - ptm
max(which(Dkt != 0)) == max(which(Akt != 0))
max(which(Dkt != 0)) == max(which(Tkt != 0)) - 1
m = max(which(Dkt != 0))
lamb = Akt[1:m]/Tkt[1:m]    # lamb_0, lamb_1 ,..., mu_(m-1)
mu = Dkt[1:m]/Tkt[2:(m+1)]  # mu_1, mu_2 ,..., mu_m
lamb
mu
plot(9:59, lamb[10:60])
plot(10:60, mu[10:60])
# lamb[is.nan(lamb)] = 0
# lamb[lamb == 0] = 0.001
# lamb[is.infinite(lamb)] = max(lamb)
# mu[is.nan(mu)] = 0
mu[mu == 0] = 0.001
# lamb[is.infinite(mu)] = max(mu)
rkt = rep(1,m+1) # r0, r1, ... ,
for(i in 2:m+1){
rkt[i] = prod(lamb[1:(i-1)])/prod(mu[1:(i-1)])
}
rkt
alphakt = rep(0,m+1)
for (i in 1:(m+1)){
alphakt[i] = rkt[i]/sum(rkt)
}
alphakt
plot(x=1:(m+1), y=alphakt)
Dkt2 = Dkt
Dkt2[Dkt == 0] = 0.1
mu2 = Dkt2[1:m]/Tkt[2:(m+1)]  #mu_1, mu_2 ,..., mu_m
mu2
rkt2 = rep(1,m+1) # r0, r1, ... ,
for(i in 2:m+1){
rkt2[i] = prod(lamb[1:(i-1)])/prod(mu2[1:(i-1)])
}
rkt2
alphakt2 = rep(0,m+1)
for (i in 1:(m+1)){
alphakt2[i] = rkt2[i]/sum(rkt2)
}
alphakt2
plot(x=1:(m+1), y=alphakt2)
print rkt2
print(rkt2)
print(paste("The result is", rkt2))
print("The result is", rkt2)
cat("The result is", rkt2)
cat("The result is", c(5,4), y)
cat("The result is", c(5,4), "y")
#### http://www.statisticsblog.com/2011/10/waiting-in-line-waiting-on-r/ ####
tmax <- 1
t <- 0
numbServers = 4
# Total time to track
precision = 100  #precision
epochSeq = seq(1, tmax*precision, 1)
meanServiceTime = .1
ptm = proc.time()
#### NHPP Arrivals ####
get_nhpp_realization <- function(lambda){
set.seed(10000)
lambda_star <- function(){
max(sapply(seq(1, tmax,length.out=1000), lambda))*2}
Lambda <- function(tupper){
integrate(f = lambda, lower = 0, upper = tupper)$value}
X <- numeric()
while(t <= tmax){
u <- runif(1)
t <- t - log(u)/lambda_star()
if(runif(1) < lambda(t)/lambda_star()) {
X <- c(X,t)
}
}
return(floor(X*precision))
}
l = 35
b = 10/35
g = 1
lambda <- function(t)  l*(1+b*sin(g*t))
arrivalEpochs <- get_nhpp_realization(lambda)
ptm1 = proc.time()
t_np = ptm1 - ptm
cat("The non-poisson simulation takes", t_np, "s" )
# Average time each person takes at the teller, discretized exponential
# distribution assumed Times will be augmented by one, so that everyone takes at
# least 1 interval to serve
# write.table(arrivalEpochs, file = "arrivalEpochs_tmax10000_prec1000.txt",
# row.names = F, col.names = F)
#### Libraries ####
# Use the proto library to treat people like objects in traditional oop
library("proto")
#### Functions ####
# R is missing a nice way to do ++, so we use this
inc <- function(x) {
eval.parent(substitute(x <- x + 1))
}
dec <- function(x) {
eval.parent(substitute(x <- x - 1))
}
set.seed(1)
# Main object, really a "proto" function
person <- proto(
intervalArrived = 0,
# How much teller time will this person demand?
serviceEpochsNeeded = (floor(rexp(1, 1/meanServiceTime)*precision) + 1),
serviceEpochsWaited = 0,
serviceEpochsWaitedAtHeadOfQueue = 0
)
#### INITIALIZATION ####
queueLengths = rep(20.5, length(epochSeq))
totalCustomers = 0
numbCustomers = rep(20.5, length(epochSeq))
serviceCompletionEpoch = rep(0, numbServers)
waitEpoch = c()
leavingTimes = c()
queue = list()
frontOfLineWaits = c()
Akt = rep(0, length(arrivalEpochs))  #Akt, k=0,1,2,
Dkt = rep(0, length(arrivalEpochs))  #Dkt, k=1,2,
Tkt = rep(0, length(arrivalEpochs))  #Tkt, k=0,1,2
k = 1 # counting arrival orders
#### Main loop ####
for(i in epochSeq) {
# Check if anyone is leaving the servers
for(j in 1:numbServers) {
if(serviceCompletionEpoch[j] == i) {
inc(Dkt[totalCustomers])
dec(totalCustomers)
# They are leaving the queue, slot to 0
serviceCompletionEpoch[j] = 0
leavingTimes = c(leavingTimes, i)
}
}
# See if a new person is to be added to the queue
while(i == arrivalEpochs[k] & k <= length(arrivalEpochs)) {
inc(Akt[totalCustomers+1])
inc(totalCustomers)
newPerson = as.proto(person$as.list())
newPerson$intervalArrived = i
queue = c(queue, newPerson)
inc(k)
}
# Can we place someone into a slot?
for(j in 1:numbServers) {
# If this slot is free
if(!serviceCompletionEpoch[j]) {
if(length(queue) > 0) {
placedPerson = queue[[1]]
serviceCompletionEpoch[j] = i + placedPerson$serviceEpochsNeeded
waitEpoch = c(waitEpoch, placedPerson$serviceEpochsWaited)
# Only interested in these if person waited 1 or more intevals at front
# of line
if(placedPerson$serviceEpochsWaitedAtHeadOfQueue) {
frontOfLineWaits = c(frontOfLineWaits,
placedPerson$serviceEpochsWaitedAtHeadOfQueue)
}
# Remove placed person from queue
queue[[1]] = NULL
}
}
}
# Everyone left in the queue has now waited one more interval to be served
if(length(queue)) {
for(j in 1:length(queue)) {
inc(queue[[j]]$serviceEpochsWaited)
}
# The (possibley new) person at the front of the queue has had to wait
# there one more interval.
inc(queue[[1]]$serviceEpochsWaitedAtHeadOfQueue)
}
# End of the interval, what is the state of things
queueLengths[i] = length(queue)
numbCustomers[i] = totalCustomers
inc(Tkt[totalCustomers+1])
}
#### Output ####
plot(queueLengths, type="o", col="blue", pch=20, main="Queue lengths over time",
xlab="Interval", ylab="Queue length")
plot(numbCustomers, type="o", col="blue", pch=20, main="# of Customers over time",
xlab="Interval", ylab="Queue length")
# plot(totalCustomers, type="o", col="blue", pch=20,
#      main="Total Customers over time", xlab="Person", ylab="Wait time")
ptm2 = proc.time()
t_sim = ptm2 - ptm1
cat("The simulation takes", t_sim, "s" )
max(which(Dkt != 0)) == max(which(Akt != 0))
max(which(Dkt != 0)) == max(which(Tkt != 0)) - 1
m = max(which(Dkt != 0))
lamb = Akt[1:m]/Tkt[1:m]    # lamb_0, lamb_1 ,..., mu_(m-1)
mu = Dkt[1:m]/Tkt[2:(m+1)]  # mu_1, mu_2 ,..., mu_m
lamb
mu
plot(9:59, lamb[10:60])
plot(10:60, mu[10:60])
# lamb[is.nan(lamb)] = 0
# lamb[lamb == 0] = 0.001
# lamb[is.infinite(lamb)] = max(lamb)
# mu[is.nan(mu)] = 0
mu[mu == 0] = 0.001
# lamb[is.infinite(mu)] = max(mu)
rkt = rep(1,m+1) # r0, r1, ... ,
for(i in 2:m+1){
rkt[i] = prod(lamb[1:(i-1)])/prod(mu[1:(i-1)])
}
rkt
alphakt = rep(0,m+1)
for (i in 1:(m+1)){
alphakt[i] = rkt[i]/sum(rkt)
}
alphakt
plot(x=1:(m+1), y=alphakt)
Dkt2 = Dkt
Dkt2[Dkt == 0] = 0.1
mu2 = Dkt2[1:m]/Tkt[2:(m+1)]  #mu_1, mu_2 ,..., mu_m
mu2
rkt2 = rep(1,m+1) # r0, r1, ... ,
for(i in 2:m+1){
rkt2[i] = prod(lamb[1:(i-1)])/prod(mu2[1:(i-1)])
}
rkt2
alphakt2 = rep(0,m+1)
for (i in 1:(m+1)){
alphakt2[i] = rkt2[i]/sum(rkt2)
}
alphakt2
plot(x=1:(m+1), y=alphakt2)
ptm2 = proc.time()
